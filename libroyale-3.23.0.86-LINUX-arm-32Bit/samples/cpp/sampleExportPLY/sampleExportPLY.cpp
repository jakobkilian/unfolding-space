/****************************************************************************\
 * Copyright (C) 2017 Infineon Technologies & pmdtechnologies ag
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 \****************************************************************************/

#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <fstream>
#include <sstream>
#include <string>

#include <royale.hpp>
#include <royale/IPlaybackStopListener.hpp>
#include <royale/IReplay.hpp>

using namespace std;

namespace
{
    /**
     * This sample is a command line application that takes an rrf filename as input and outputs a
     * PLY file for each frame of the recording (into the current working directory).
     *
     * Royale's API for playing an .rrf file is the same as for capturing data from a camera, you
     * use CameraManager to create an ICameraDevice for the .rrf file, and then receive the data as
     * IDepthDataListener::onNewData callbacks.
     *
     * With a recording, the onNewData callback isn't time-critical, so doesn't require the
     * thread-handling of sampleRetrieveData. A recording also has a beginning, an end, and the
     * possibility to fast-forward and rewind, which are supported through the IReplay interface.
     */
    class MyListener : public royale::IDepthDataListener
    {
    public:
        MyListener (string rrfFile, uint32_t numFrames) :
            m_frameNumber (0),
            m_numFrames (numFrames),
            m_rrfFile (std::move (rrfFile))
        {
        }

        void writePLY (const string &filename, const royale::DepthData *data)
        {
            // For an explanation of the PLY file format please have a look at
            // https://en.wikipedia.org/wiki/PLY_(file_format)

            ofstream outputFile;
            stringstream stringStream;

            outputFile.open (filename, ofstream::out);

            if (outputFile.fail())
            {
                cerr << "Outputfile " << filename << " could not be opened!" << endl;
                return;
            }
            else
            {
                // if the file was opened successfully write the PLY header
                stringStream << "ply" << endl;
                stringStream << "format ascii 1.0" << endl;
                stringStream << "comment Generated by sampleExportPLY" << endl;
                stringStream << "element vertex " << data->points.size() << endl;
                stringStream << "property float x" << endl;
                stringStream << "property float y" << endl;
                stringStream << "property float z" << endl;
                stringStream << "element face 0" << endl;
                stringStream << "property list uchar int vertex_index" << endl;
                stringStream << "end_header" << endl;

                // output XYZ coordinates into one line
                for (size_t i = 0; i < data->points.size(); ++i)
                {
                    stringStream << data->points.at (i).x << " " << data->points.at (i).y << " " << data->points.at (i).z << endl;
                }

                // output stringstream to file and close it
                outputFile << stringStream.str();
                outputFile.close();
            }
        }

        void onNewData (const royale::DepthData *data) override
        {
            stringstream filename;

            m_frameNumber++;

            cout << "Exporting frame " << m_frameNumber << " of " << m_numFrames << endl;

            filename << m_frameNumber << ".ply";
            writePLY (filename.str(), data);
        }

    private:
        uint32_t m_frameNumber; // The current frame number
        uint32_t m_numFrames;   // Total number of frames in the recording
        string m_rrfFile;       // Recording file that was opened
    };

    class MyPlaybackStopListener : public royale::IPlaybackStopListener
    {
    public:
        MyPlaybackStopListener()
        {
            m_playbackRunning = true;
        }

        void onPlaybackStopped() override
        {
            lock_guard<mutex> lock (m_stopMutex);
            m_playbackRunning = false;
        }

        void waitForStop()
        {
            bool running = true;
            do
            {
                {
                    lock_guard<mutex> lock (m_stopMutex);
                    running = m_playbackRunning;
                }

                this_thread::sleep_for (chrono::milliseconds (50));
            }
            while (running);
        }

    private:
        mutex m_stopMutex;      // Mutex to synchronize the access to m_playbackRunning
        bool m_playbackRunning; // Shows if the playback is still running
    };

}

int main (int argc, char *argv[])
{
    // This is the data listener which will receive callbacks.  It's declared
    // before the cameraDevice so that, if this function exits with a 'return'
    // statement while the camera is still capturing, it will still be in scope
    // until the cameraDevice's destructor implicitly deregisters the listener.
    unique_ptr<MyListener> listener;

    // PlaybackStopListener which will be called as soon as the playback stops.
    MyPlaybackStopListener stopListener;

    // Royale's API treats the .rrf file as a camera, which it captures data from.
    unique_ptr<royale::ICameraDevice> cameraDevice;

    // check the command line for a given file
    if (argc < 2)
    {
        cout << "Usage " << argv[0] << " rrfFileToExport" << endl;
        cout << endl;
        cout << "Each frame of the recording is saved as a separate .ply file " << endl;
        cout << "in the current directory." << endl;
        return 1;
    }

    // Use the camera manager to open the recorded file, this block scope is because we can allow
    // the CameraManager to go out of scope once the file has been opened.
    {
        royale::CameraManager manager;

        // create a device from the file
        cameraDevice = manager.createCamera (argv[1]);
    }

    // if the file was loaded correctly the cameraDevice is now available
    if (cameraDevice == nullptr)
    {
        cerr << "Cannot load the file " << argv[1] << endl;
        return 1;
    }

    // cast the cameraDevice to IReplay which offers more options for playing
    // back recordings
    auto replayControls = dynamic_cast<royale::IReplay *> (cameraDevice.get());

    if (replayControls == nullptr)
    {
        cerr << "Unable to cast to IReplay interface" << endl;
        return 1;
    }

    // IMPORTANT: call the initialize method before working with the camera device
    if (cameraDevice->initialize() != royale::CameraStatus::SUCCESS)
    {
        cerr << "Cannot initialize the camera device" << endl;
        return 1;
    }

    // turn off the looping of the playback
    replayControls->loop (false);

    // Turn off the timestamps to speed up the conversion. If timestamps are enabled, an .rrf that
    // was recorded at 5FPS will generate callbacks to onNewData() at only 5 callbacks per second.
    replayControls->useTimestamps (false);

    // retrieve the total number of frames from the recording
    auto numFrames = replayControls->frameCount();

    // Create and register the data listener
    listener.reset (new MyListener (argv[1], numFrames));
    if (cameraDevice->registerDataListener (listener.get()) != royale::CameraStatus::SUCCESS)
    {
        cerr << "Error registering data listener" << endl;
        return 1;
    }

    // register a playback stop listener. This will be called as soon
    // as the file has been played back once (because loop is turned off)
    replayControls->registerStopListener (&stopListener);

    // start capture mode
    if (cameraDevice->startCapture() != royale::CameraStatus::SUCCESS)
    {
        cerr << "Error starting the capturing" << endl;
        return 1;
    }

    // block until the playback has finished
    stopListener.waitForStop();

    // stop capture mode
    if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
    {
        cerr << "Error stopping the capturing" << endl;
        return 1;
    }

    return 0;
}
